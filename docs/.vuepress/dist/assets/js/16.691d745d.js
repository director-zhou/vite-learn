(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{369:function(t,e,v){"use strict";v.r(e);var _=v(45),s=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"二-性能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二-性能"}},[t._v("#")]),t._v(" (二) 性能")]),t._v(" "),v("p",[t._v("一些包将它们的 "),v("code",[t._v("ES")]),t._v(" 模块构建作为许多单独的文件相互导入。例如，"),v("code",[t._v("lodash-es")]),t._v(" 有超过 "),v("code",[t._v("600")]),t._v(" 个内置模块！当我们执行 "),v("code",[t._v("import { debounce } from 'lodash-es'")]),t._v(" 时，浏览器同时发出 "),v("code",[t._v("600")]),t._v(" 多个 "),v("code",[t._v("HTTP")]),t._v(" 请求！尽管服务器在处理这些请求时没有问题，但大量的请求会在浏览器端造成网络拥塞，导致页面的加载速度相当慢。")]),t._v(" "),v("h2",{attrs:{id:"esm-模块在浏览器中的加载机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#esm-模块在浏览器中的加载机制"}},[t._v("#")]),t._v(" ESM 模块在浏览器中的加载机制")]),t._v(" "),v("p",[t._v("在开发中, 为了更好的维护代码, 我们会将会进行函数柯里化, 模块化, 和一些公共方法的抽取进行复用, 在一个"),v("code",[t._v("ESM")]),t._v(" 的模块中引入了"),v("code",[t._v("N")]),t._v("个其它模块, 在第二层"),v("code",[t._v("N")]),t._v("个模块中引又分别引入了"),v("code",[t._v("N")]),t._v("个模块, 将一万行代码分别拆分成"),v("code",[t._v("30")]),t._v("个小模块进行维护, 分别向需要的模块中进行引入, "),v("code",[t._v("lodash-es")]),t._v("就是这样的情况, 其实往往在开发中我们避免不了这种情况。")]),t._v(" "),v("p",[t._v("当请求到入口模块时, 会将依次加载所有的引入模块, 直到最后的文件没有任何存在的引用模块")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),v("p",[t._v("引入即加载,只要在头部通过import引入模块, 无论是动态分配, 还是按名导入, 即使没有执行此")])]),t._v(" "),v("h2",{attrs:{id:"stalled-阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#stalled-阻塞"}},[t._v("#")]),t._v(" Stalled（阻塞）")]),t._v(" "),v("p",[t._v("浏览器对同一个主机域名的并发连接数有限制, "),v("code",[t._v("Chrome")]),t._v("就有六个并行连接线程, 其余的"),v("code",[t._v("24")]),t._v("个请求将会进行等待, 连接数的切换和创建也会造成一定的时间消耗, 这样会导致网络拥塞。")])])}),[],!1,null,null,null);e.default=s.exports}}]);