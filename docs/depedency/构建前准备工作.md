所有依赖已经收集完毕, 接下来需要做的对收集完的依赖进行一些处理,`esbuild`生成具有最低公共祖先基的嵌套目录输出,这是不可预测的，因此很难分析输入和输出。所以展平所有`ID`以消除斜杠, 在插件中，将条目作为虚拟文件读取以保留路径。


## 展平所有入口ID

```js
const flatIdDeps: Record<string, string> = {}
export const flattenId = (id: string): string => id.replace(/[\/\.]/g, '_')
const flatIdDeps: Record<string, string> = {}
for (const id in deps) {
  const flatId = flattenId(id)
  flatIdDeps[flatId] = deps[id]
}
```

声明`flatIdDeps`为扁平化的依赖映射，把 `/` 与 `.` 重写为 `_`

```js
// 转化示例：

@ant-design-vue/use   =>  @ant-design-vue_use
lodash.debounce  => lodash_debounce
```

`flatIdDeps` 与 `deps` 不同的就是一个是展平后的`key`值

## es-module-lexer 对依赖的模块内容进行词法解析

```js
import { init, parse } from 'es-module-lexer'
const idToExports: Record<string, ExportsData> = {}
const flatIdToExports: Record<string, ExportsData> = {}
await init
for (const id in deps) {
  const entryContent = fs.readFileSync(deps[id], 'utf-8')
  const exportsData = parse(entryContent) as ExportsData
  for (const { ss, se } of exportsData[0]) {
    const exp = entryContent.slice(ss, se)
    if (/export\s+\*\s+from/.test(exp)) {
      exportsData.hasReExports = true
    }
  }
  idToExports[id] = exportsData
  flatIdToExports[flatId] = exportsData
}
```
> 解析依赖入口文件中的内容


对依赖进行循环, `entryContent`变量收集依赖入口文件的内容
`exportsData`对入口内容进行`paser`进行解析内容

```js
// 引入demo
import one from './one.js';
export { two } from './two.js';
export const three = 3
console.log(1)
function demo() {
  console.log(2)
}
```

`exportsData`词法解析为：

```js
[
  { n: './one.js', s: 22, e: 30, ss: 5, se: 31, d: -1, a: -1 },
  { n: './two.js', s: 58, e: 66, ss: 37, se: 67, d: -1, a: -1 }
] [ 'two', 'three' ] true
```

数组中第一个下标为对`import`词法解析的内容
数组中第二个下标为`export`词法解析的内容


> 截取import内容

对`import`的词法进行循环,截取每行`import`的全部内容

```js
// 截取的内容
import one from './one.js';
export { two } from './two.js';
```

将对截取的条目进行匹配, 匹配方式 `/export\s+\*\s+from/`
如果有同时导入导出的语法,则在解析后的对象`exportsData`上设置`hasReExports:true`

> 存储词法分析后的内容

对每个依赖的词法解析后的结果进行对象存储

1. `idToExports` 原始依赖模块名称的存储
2. `flatIdToExports` 展平后依赖模块名称的存储

## 定义全局常量替换

在构建时候, 代码块的内容往往存在一些全局的常量，有些根据项目封装的`node_modules`包会存在以下代码内容

```js
if (process.env.NODE_ENV === 'development') {
  XXXXX
}
if (process.env.TEST_ENV === 'test') {
  XXXX
}
```

在构建中`process.env.TEST_ENV`和`process.env.NODE_ENV`并不会读取环境变量中的内容,通过`define`可以把环境变量作为常量进行对待,启动时可以进行对环境量变进行获取,写入`define`之后, `esbuild`在构建时传入`define`,会进行自动替换这些环境变量。

> 定义内容的环境常量
```js
const define: Record<string, string> = {
  'process.env.NODE_ENV': JSON.stringify(config.mode)
}
```

对`pocess.env.NODE_ENV`定义为设置的`mode`模式

> 寻找自定义常量

```js
for (const key in config.define) {
  const value = config.define[key]
  define[key] = typeof value === 'string' ? value : JSON.stringify(value)
}
```

在`config`配置中有`define` **API**选项，通过此选项可以自定义一些常量名和值,同时把这些定义的常量赋值给`esbuild`需要的`define`变量上。这样`esbuild`在构建时就可以进行未能解析的常量替换


> 开始构建

```js
const { plugins = [], ...esbuildOptions } =
config.optimizeDeps?.esbuildOptions ?? {}
const result = await build({
  absWorkingDir: process.cwd(),
  entryPoints: Object.keys(flatIdDeps),
  bundle: true,
  format: 'esm',
  external: config.optimizeDeps?.exclude,
  logLevel: 'error',
  splitting: true,
  sourcemap: true,
  outdir: cacheDir,
  treeShaking: 'ignore-annotations',
  metafile: true,
  define,
  plugins: [
    ...plugins,
    esbuildDepPlugin(flatIdDeps, flatIdToExports, config, ssr)
  ],
  ...esbuildOptions
})
```

通过`esbuild`的`build`方法进行开始构建。

1. `entryPoints` 构建入口,写入的则是展平化的依赖模块路径
2. `bundle` 进行递归的方式进行解析。
3. `format` 构建成esm导出的模块
4. `external` 过滤optimizeDeps.exclude 强制排出的依赖
5. `logLevel` 提示级别
6. `splitting` 对构建时对相同的依赖做代码分隔
7. `sourcemap` 产生sourcemap文件
8. `outdir` 输出目录，为设置缓存文件的目录
9. `treeShaking` 构建时去除注释内容
10. `metafile` 生成文件元信息
11. `define` 常量替换的内容
12. `plugins` 构建插件